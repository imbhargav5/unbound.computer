name: Publish Release

on:
  workflow_dispatch: {}
  pull_request:
    types:
      - closed
    branches:
      - main

concurrency:
  group: release-publish-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  rust-checks:
    name: Rust Checks
    if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'release/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install shell dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y zsh

      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: rust cache targets
        id: rust-cache
        run: |
          echo "workspaces<<EOF" >> "$GITHUB_OUTPUT"
          ./scripts/ci/rust-checks.sh cache-targets >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: ${{ steps.rust-cache.outputs.workspaces }}

      - name: fmt
        run: ./scripts/ci/rust-checks.sh fmt

      - name: clippy
        run: ./scripts/ci/rust-checks.sh clippy

      - name: test
        run: ./scripts/ci/rust-checks.sh test

  publish:
    name: Publish Release
    # Only run if PR was merged and it's a release branch
    if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'release/')
    needs: rust-checks
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      release_exists: ${{ steps.check_release.outputs.exists }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: CI Setup
        uses: ./.github/actions/ci-setup

      - name: Get version from package.json
        id: version
        run: |
          VERSION=$(pnpm tsx scripts/release/get-current-version.ts)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Publishing version: $VERSION"

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check if release already exists
        id: check_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="v${VERSION}"

          # Check if release already exists on GitHub
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists, skipping entire release process"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create and push git tag
        if: steps.check_release.outputs.exists != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="v${VERSION}"

          # Fetch tags from remote to ensure we have the latest
          git fetch --tags

          # Check if tag already exists (locally or remotely)
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping tag creation"
          else
            git tag -a "$TAG" -m "Release $TAG"
            git push origin "$TAG"
            echo "Created and pushed tag: $TAG"
          fi

      - name: Generate release notes
        if: steps.check_release.outputs.exists != 'true'
        run: |
          pnpm tsx scripts/release/generate-release-notes.ts ${{ steps.version.outputs.version }} > /tmp/release-notes.md
          echo "Generated release notes:"
          cat /tmp/release-notes.md

      - name: Create GitHub Release
        if: steps.check_release.outputs.exists != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="v${VERSION}"

          gh release create "$TAG" \
            --title "$TAG" \
            --notes-file /tmp/release-notes.md \
            --latest
          echo "Created GitHub Release: $TAG"

      - name: Cleanup release files
        if: steps.check_release.outputs.exists != 'true'
        run: |
          pnpm tsx scripts/release/cleanup-releases.ts

      - name: Commit cleanup
        if: steps.check_release.outputs.exists != 'true'
        run: |
          # Check if there are changes to commit
          if git diff --quiet .releases/; then
            echo "No release files to clean up"
          else
            git add .releases/
            git commit -m "chore: cleanup release files after v${{ steps.version.outputs.version }}"
            git push origin main
            echo "Cleaned up release files"
          fi

      - name: Delete release branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/${BRANCH}" || echo "Branch already deleted or doesn't exist"
          echo "Deleted branch: $BRANCH"

  macos-artifacts:
    name: Build macOS Release Artifacts
    needs: publish
    if: needs.publish.outputs.release_exists != 'true'
    runs-on: macos-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: CI Setup
        uses: ./.github/actions/ci-setup

      - name: Configure signing keychain
        if: ${{ secrets.MACOS_CERT_BASE64 != '' }}
        env:
          MACOS_CERT_BASE64: ${{ secrets.MACOS_CERT_BASE64 }}
          MACOS_CERT_PASSWORD: ${{ secrets.MACOS_CERT_PASSWORD }}
        run: |
          KEYCHAIN_PASSWORD="$(uuidgen)"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          echo "$MACOS_CERT_BASE64" | base64 --decode > /tmp/macos-cert.p12 2>/dev/null || echo "$MACOS_CERT_BASE64" | base64 -D > /tmp/macos-cert.p12
          security import /tmp/macos-cert.p12 -k build.keychain -P "$MACOS_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/xcrun
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          security list-keychain -d user -s build.keychain

      - name: Generate Release.xcconfig
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_PUBLISHABLE_KEY: ${{ secrets.SUPABASE_PUBLISHABLE_KEY }}
        run: |
          cat > apps/macos/Config/Release.xcconfig <<EOF
          API_URL = https://unbound.computer
          RELAY_URL = wss://unbound-computer.fly.dev
          SUPABASE_URL = ${SUPABASE_URL}
          SUPABASE_PUBLISHABLE_KEY = ${SUPABASE_PUBLISHABLE_KEY}
          INFOPLIST_KEY_API_URL = \$(API_URL)
          INFOPLIST_KEY_RELAY_URL = \$(RELAY_URL)
          INFOPLIST_KEY_SUPABASE_URL = \$(SUPABASE_URL)
          INFOPLIST_KEY_SUPABASE_PUBLISHABLE_KEY = \$(SUPABASE_PUBLISHABLE_KEY)
          MARKETING_VERSION = \$(RELEASE_VERSION)
          CURRENT_PROJECT_VERSION = \$(RELEASE_BUILD_NUMBER)
          EOF

      - name: Build release artifacts
        env:
          MACOS_TEAM_ID: ${{ secrets.MACOS_TEAM_ID }}
          MACOS_SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
          MACOS_RELEASE_VERSION: ${{ needs.publish.outputs.version }}
          MACOS_BUILD_NUMBER: ${{ github.run_number }}
        run: |
          ./scripts/release/build-macos-release.sh

      - name: Notarize artifacts
        env:
          MACOS_TEAM_ID: ${{ secrets.MACOS_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_NOTARYTOOL_KEY_ID: ${{ secrets.APPLE_NOTARYTOOL_KEY_ID }}
          APPLE_NOTARYTOOL_ISSUER_ID: ${{ secrets.APPLE_NOTARYTOOL_ISSUER_ID }}
          APPLE_NOTARYTOOL_PRIVATE_KEY: ${{ secrets.APPLE_NOTARYTOOL_PRIVATE_KEY }}
        run: |
          NOTARY_PROFILE="unbound-release"
          if [[ -n "$APPLE_NOTARYTOOL_KEY_ID" && -n "$APPLE_NOTARYTOOL_ISSUER_ID" && -n "$APPLE_NOTARYTOOL_PRIVATE_KEY" ]]; then
            echo "$APPLE_NOTARYTOOL_PRIVATE_KEY" > /tmp/AuthKey.p8
            xcrun notarytool store-credentials "$NOTARY_PROFILE" \
              --key /tmp/AuthKey.p8 \
              --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
              --issuer "$APPLE_NOTARYTOOL_ISSUER_ID"
          elif [[ -n "$APPLE_ID" && -n "$APPLE_ID_PASSWORD" ]]; then
            xcrun notarytool store-credentials "$NOTARY_PROFILE" \
              --apple-id "$APPLE_ID" \
              --team-id "$MACOS_TEAM_ID" \
              --password "$APPLE_ID_PASSWORD"
          else
            echo "Notarization credentials missing; skipping notarization."
            exit 0
          fi

          xcrun notarytool submit "dist/macos/unbound-macos-v${{ needs.publish.outputs.version }}-arm64.zip" --keychain-profile "$NOTARY_PROFILE" --wait
          xcrun notarytool submit "dist/macos/unbound-macos-v${{ needs.publish.outputs.version }}-x86_64.zip" --keychain-profile "$NOTARY_PROFILE" --wait

          ARM_APP="$(find dist/macos/export-arm64 -maxdepth 1 -name '*.app' -print -quit)"
          X86_APP="$(find dist/macos/export-x86_64 -maxdepth 1 -name '*.app' -print -quit)"
          if [[ -n "$ARM_APP" ]]; then
            xcrun stapler staple "$ARM_APP"
          fi
          if [[ -n "$X86_APP" ]]; then
            xcrun stapler staple "$X86_APP"
          fi

      - name: Upload artifacts to GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="v${{ needs.publish.outputs.version }}"
          gh release upload "$TAG" dist/macos/* --clobber
